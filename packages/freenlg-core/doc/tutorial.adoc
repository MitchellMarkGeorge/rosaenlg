= FreeNLG Tutorial

ifeval::["{outfilesuffix}" == ".html"]
link:tutorial.pdf[PDF version]
endif::[]

image::freenlg-logo.png[FreeNLG logo]

_successfully tested with FreeNLG 0.8.1_

== Our goal

This tutorial will guide you through a basic use of FreeNLG. You will apply FreeNLG to a basic usecase which is generating texts ( Natural Language texts) to describe OnePlus smartphones.

* It will not guide you through https://pugjs.org/[Pug] - you should read a basic Pug tutorial as a prerequisite.
* It does not replace the <<mixins_ref.adoc#,Mixings reference documentation>>.

Our OnePlus phone data will come from https://www.phonearena.com/phones/compare/OnePlus-5T,OnePlus-5,OnePlus-3T/phones/10695,10501,10313 .

== Node environment setup

You can skip this part if you are familiar with node.js environment setup as it's completely standard.

* install `node.js` and `npm` in your environment
* create a `tutorial` folder somewhere
* `npm init` and just accept whatever it says/asks
* `npm install freenlg` will download freenlg and end up with something like `+ freenlg@x.x.x`
* create an `tuto.js` file, just put `console.log("hello NLG");` inside of it
* `node tuto.js` should output `hello NLG` (PS that's not really Natural Language Generation yet)

== Initial data

Our initial data. Put it in your `tuto.js` file.
[source,javascript]
....
include::tuto.js[tags=data]
....

== Plumbing & first texts

You need `pug` and `freenlg` libs, thus, add this at the beginning of your `tuto.js` file:
[source,javascript]
....
include::tuto.js[tags=require]
....

In the same file, call a pug template (we will create the template just after):
[source,javascript]
....
console.log( pug.renderFile('tuto.pug', {
  util: new NlgLib({language: 'en_US'}),
  phone: phones[0]
}) );
....
This will render the `tuto.pug` template. Parameters:

* `util: new NlgLib({language: 'en_US'}),` is mandatory. You have to create the `NlgLib` object and it *must* be put in the `util` property when triggering the rendering.
* for the other properties you are free to organize them as you want; here we just put a `phone` property with our first phone.


Create a `tuto.pug` file with this content:
....
include::tuto_header.pug[]

p #{phone.name}
....
This first template is just standard Pug syntax: we output the name of the phone.
The first line `include node_modules/freenlg/mixins/main.pug` is mandatory for FreeNLG to work properly.

When you render the template (using `node tuto.js`) you should get: +
_<p>OnePlus 5T</p>_

_(ok, it's not really NLG yet)_


== Enumerations with `assemble`

Let's talk about the colors of the phone: we want to output _Available colors are aaa, bbb and ccc._

Create a mixin dedicated to listing colors (in your `tuto.pug` file):
....
mixin colors
  | the phone's available available colors are #[+foreach(phone.colors, null, { separator:',', last_separator:'and' })] .
....

* the `foreach` is a FreeNLG mixin. It's like a loop, with additionnal NLG features.
* `{ separator:',', last_separator:'and' }` tells the `foreach` mixin that the standard separator is the comma, and that `and` should be used between the two last ones.

Call the mixin:
....
p #{phone.name} . #[+colors]
....

Run it, output should be: _<p>OnePlus 5T . the phone's available colors are Black  ,  Red  and  White .</p>_ - which is quite ugly:

* too many spaces
* `the` should be capitalized

TIP: Do not manually capitalize `the`. It's better to let the NLG system do this task.

== Clean the output or Surface Realization

FreeNLG has a cleaning feature (this cleaning is called "Surface Realization" in NLG) which capitalizes properly, removes extra spaces and ponctuation, and at last does some NLG activities like transforming `a industry` into `an industry`.

Just reorganize your code using the `filter` js function:
[source,javascript]
....
var nlgLib = new NlgLib({language: 'en_US'});
  
var res = nlgLib.filter(
  pug.renderFile('tuto.pug', {
    util: nlgLib,
    phone: phones[0]
  })
);
console.log( res );
....

 Output should be: _OnePlus 5T. The phone's available colors are Black, Red and White._

TIP: Now we are doing Natural Language Generation ðŸš€


== Looping on all the phones

Let's generate some text for each phone. In your `tuto.js` file:
[source,javascript]
....
include::tuto.js[tags=mainLoop]
....

* We could have had the main loop directly in your the pug template. Still, looping outside of the template allows an easy reset of the `NlgLib` object, and is better for performance.
* The `NlgLib` constructor accepts an old one as a parameter. It's faster not to recreate the object from scratch each time as linguistic resources are cached.

You should get: +
_<p>OnePlus 5T</p><p>The phone's available colors are Black, Red and White.</p>_ +
_<p>OnePlus 5</p><p>The phone's available colors are Gold and Gray.</p>_ +
_<p>OnePlus 3T</p><p>The phone's available colors are Black, Gold and Gray.</p>_


== Basic synonyms

Readers love when texts are not repetitive. Let's add some very basic synonyms: _tints_ and _tones_ are synonyms of _colors_.
Change your `colors` mixin:
....
mixin colors
  | the phone's available #[+syn('colors', 'tints', 'tones')]
  | are #[+foreach(phone.colors, null, { separator:',', last_separator:'and' })] .
....

Run it multiple times and you should have different outputs.

== More synonyms

The `syn` mixin is perfect for words or part of sentences. But let's say we want create some introduction texts, and that we want to have diversity.

Let's put all these different introductions in a dedicated mixin:
....
- setSize('intro', 3)
mixin intro(rnd)
  case rnd
    when 1
      | the #{phone.name} is really a fantastic phone.
    when 2
      | i really love the new #{phone.name}.
    when 3
      | #{phone.name} : a great phone !
....

* `- setSize('title', 3)` is mandatory: it indicates FreeNLG the number of alternatives.
* You can put whatever you want in each alternative (in each `when`), but you have to respect the case/when structure.

Let's call this new mixin:
....
mixin phone
  | #[+syno_sentences('intro')] .
  | #[+colors] .

p #[+phone]
....

`syno_sentences` wraps the `intro` mixin and indicates to FreeNLG that it has to choose a synonym.

You should get: +
_<p>I really love the new OnePlus 5T. The phone's available tints are Black, Red and White.</p>_ +
_<p>I really love the new OnePlus 5. The phone's available tints are Gold and Gray.</p>_ +
_<p>OnePlus 3T: a great phone! The phone's available tones are Black, Gold and Gray.</p>_

Intros are chosen randomly so you might have repetitions.

== List parts of a sentence

Let's talk about the display: physical size and screen-to-body ratio. We want to output something like _it has a a physical size of 6 inches and a a screen-to-body ratio of 80.43 %_.
We could build a big static sentence, but structuring the code will give us more flexibility.

Let's cut our big sentence in chunks, one for each property:
....
include::tuto.pug[tags=displayMixin]
....

* `valWithUnit` is a very basic mixin that will output the value, a space, and the unit.
* you can see the `display` mixin as a kind of list.

We could output our text using `#[+display(1)]` and then `#[+display(2)]` but you can ask FreeNLG to do it:
....
mixin phone
  | #[+syno_sentences('intro')] .
  | #[+colors] .
  | #[+assemble('display')] .
....

You should get an ugly result. The beginning of the text is missing, and also the separators. Let's fix that:
....
  | #[+assemble('display', { begin_with_general: 'it has a display with', separator:',', last_separator:'and', end:'.' })]
....

* `begin_with_general` and `end` tell the `assemble` mixin what the texts should begin with. You could have put them outside the mixin (just before and after), but it's a good practice to put them inside: for instance, when the list of the elements to enumerate is empty, `assemble` will not output the `begin_with_general` content.
* `separator` and `last_separator` work exactly the same way as in the `foreach` mixin.

You should get better texts: +
_<p>The OnePlus 5T is really a fantastic phone. The phone's available tones are Black, Red and White. It has a display with a physical size of 6 inches and a screen-to-body ratio of 80.43 %.</p>_ +
_<p>OnePlus 5: a great phone! The phone's available tones are Gold and Gray. It has a display with a physical size of 5.5 inches and a screen-to-body ratio of 72.93 %.</p>_ +
_<p>OnePlus 3T: a great phone! The phone's available colors are Black, Gold and Gray. It has a display with a physical size of 5.5 inches and a screen-to-body ratio of 73.15 %.</p>_ +


You can add some diversity by randomly changing the order of the output by adding the `shuffle` parameter:
....
| #[+assemble('display', { begin_with_general: 'it has a display with', separator:',', last_separator:'and', shuffle:true, end:'.' })]
....


_<p>The OnePlus 5T is really a fantastic phone. The phone's available colors are Black, Red and White. It has a display with a screen-to-body ratio of 80.43 % and a physical size of 6 inches.</p>_ +
_<p>The OnePlus 5 is really a fantastic phone. The phone's available tints are Gold and Gray. It has a display with a physical size of 5.5 inches and a screen-to-body ratio of 72.93 %.</p>_ +
_<p>I really love the new OnePlus 3T. The phone's available colors are Black, Gold and Gray. It has a display with a physical size of 5.5 inches and a screen-to-body ratio of 73.15 %.</p>_

== Even more shuffle

First let's add text some about the battery:
....
  | this phone has a battery of #[+valWithUnit(phone.battery, 'mAh')] .
....

Now we have a decent volume of text. But we would like to have more variability: we always talk about colors, the display, and the battery, in this order, but it could be in any order. Let's put all our text chunks in an `assemble` structure, and add a `shuffle`:
....
- setSize('phone_chunks', 3)
mixin phone_chunks(pos)
  case pos
    when 1
      | #[+colors]
    when 2
      | #[+assemble('display', { begin_with_general: 'it has a display with', separator:',', last_separator:'and', shuffle:true })]
    when 3
      | this phone has a battery of #[+valWithUnit(phone.battery, 'mAh')]

include::tuto.pug[tags=phoneMixin]
....

== Anaphoras

There is a hidden structure behind the way we talk about the phone :

* The first time we talk about it we use the name of the phone.
* The next times we use either `the phone`, `it`, or `this phone`.

This is called _anaphoras_ in NLG. The first time we talk about something we use its _representant_ representation and after we use the _anaphora_ representation. We want FreeNLG to care for that automatically.

Let's create 2 mixins, one for each kind of representant:
....
mixin phone_ref(obj, params)
  | #{obj.name}

mixin phone_ana(obj, params)
  | #[+syn('the phone', 'this phone', 'it')]
....

TIP: The first parameter, `obj`, is the phone itself. `#{obj.name}` is exactly the same as `#{phone.name}`.

We also have to register them:
....
include::tuto.pug[tags=main]
....

Now we can use them everywhere:
....
mixin colors
  | #[+value(phone)]'s available #[+syn('colors', 'tints', 'tones')]
  | are #[+foreach(phone.colors, null, { separator:',', last_separator:'and' })] .

include::tuto.pug[tags=introMixin]
....

In the `phone_chunks` mixin:
....
      | #[+value(phone)] has a battery of #[+valWithUnit(phone.battery, 'mAh')]
....

We have to change the structure for the `it has a display with`, as we cannot put a `value` directly in the `begin_with_general` structure. It has to be a string or a mixin:
....
include::tuto.pug[tags=mixinItHasADisplay]
...
include::tuto.pug[tags=assembleDisplay]
....

This is what you should get: +
_<p>OnePlus 5T: a great phone! It has a display with a physical size of 6 inches and a screen-to-body ratio of 80.43 %. It has a battery of 3300 mAh. It's available tones are Black, Red and White.</p>_ +
_<p>I really love the new OnePlus 5. This phone has a display with a physical size of 5.5 inches and a screen-to-body ratio of 72.93 %. The phone has a battery of 3300 mAh. This phone's available tints are Gold and Gray.</p>_ +
_<p>The OnePlus 3T is really a fantastic phone. This phone's available colors are Black, Gold and Gray. It has a display with a physical size of 5.5 inches and a screen-to-body ratio of 73.15 %. This phone has a battery of 3400 mAh.</p>_


It's pretty decent, but there's one issue: you can trigger _It's available tones are_ which is wrong. It should be either _the phone's_, _this phone's_, or _its_.


== Conditional texts

We could use different techniques to address that, but a pretty straightforward solution is just to forbid the use of `it` at this specific place.

Let's add a flag when calling the anaphora: we just don't want _it_ to be triggered:
....
include::tuto.pug[tags=colorsMixinNotIt]
....

Now we have to:

* catch this flag in our anaphora mixin
* use the `syno_sentence` structure instead of `syn` to be able to write the condition

....
mixin phone_ana(obj, params)
  | #[+syno_sentences('phone_ana_syn', params)]

- setSize('phone_ana_syn', 3)
mixin phone_ana_syn(rnd, params)
  case rnd
    when 1
      | the phone
    when 2
      | this phone
    when 3
      if !hasFlag(params, 'NOT_IT')
        | it
....

See how we keep `params` all along the way.

Generate the texts and you should see that the _It's_ have disappeared.

TIP: When an empty synonym is triggered (which can happen here), FreeNLG will just choose another one.

Still we can have this kind of output: +
_<p>The OnePlus 5T is really a fantastic phone. This phone has a display with a screen-to-body ratio of 80.43 % and a physical size of 6 inches. This phone's available tints are Black, Red and White. This phone has a battery of 3300 mAh.</p>_

We have 3 times _This phone_ here which is not perfect. How could we avoid that?

== Change synonym mode

Instead of choosing synonyms randomly, we can just trigger them in sequence. This will avoid close repetitions:
....
- setSize('phone_ana_syn', 3)
- setSynoType('phone_ana_syn', 'sequence')
....

Now we should have less repetitions in our synonyms for the phone.


== Fancier sentences and "has said"

Let's generate a fancier sentence combining display size and battery capacity: _The phone has a display with a screen-to-body ratio of 73.15 % and a physical size of 5.5 inches along with a battery of 3400 mAh._

This is quite straightforward:
....
| #[+assemble('display', { begin_with_general: 'itHasADisplay', separator:',', last_separator:'and', shuffle:true })]
| along with a battery of #[+valWithUnit(phone.battery, 'mAh')]
....

The problem is, _we don't want to talk about the battery twice_. We could just remove the standard battery sentence (_The phone has a battery of 3400 mAh_), but let's try to *trigger the battery sentence only if we have not talked about the battery before*. This is where `hasSaid` and `recordSaid` come in.

....
include::tuto.pug[tags=hasSaid]
....

The pattern hasSaid/recordSaid pattern, here is twice, is the following: _if we haven't talked about something:_

. _We talk about it_
. _We record that we talked about it_

TIP: You must use these built-in mechanisms and not rely on your own variables or hashmaps that you would set along text generation, as FreeNLG goes back and forth in the text rendering.

You should get those nice sentences:+
_<p>OnePlus 5T: a great phone! The phone has a battery of 3300 mAh. This phone's available tints are Black, Red and White. It has a display with a physical size of 6 inches and a screen-to-body ratio of 80.43 %.</p>_ +
_<p>OnePlus 5: a great phone! The phone has a battery of 3300 mAh. This phone has a display with a physical size of 5.5 inches and a screen-to-body ratio of 72.93 %. The phone's available colors are Gold and Gray.</p>_


== Congratulations!

*Sincere Congratulations!* ðŸŽ†

== Even more

We have gone through some aspects of NLG with this tutorial. 

There are some other features you can explore, for instance:

* automatic a / an : `a apple` => `an apple`, `a hour` => `an hour`
* agreement of verbs (especially the irregular ones)
* agreement of words: `tomato` => `tomatoes`
* etc.


== Final version of the code

`tuto.js`
[source,javascript]
....
include::tuto.js[]
....

`tuto.pug`
....
include::tuto_header.pug[]
include::tuto.pug[]
....
