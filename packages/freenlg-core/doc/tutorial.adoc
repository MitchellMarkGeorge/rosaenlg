= FreeNLG Tutorial

ifeval::["{outfilesuffix}" == ".html"]
link:tutorial.pdf[PDF version]
endif::[]

image::freenlg-logo.png[FreeNLG logo]

_successfully tested with FreeNLG 0.9.0_

== Our goal

This tutorial will guide you through a basic use of FreeNLG. You will apply FreeNLG to a basic usecase which is generating texts (Natural Language texts) to describe OnePlus smartphones.

* It will *not* guide you through https://pugjs.org/[Pug] - you should read a basic Pug tutorial as a prerequisite.
* It does *not* replace the <<mixins_ref.adoc#,Mixings reference documentation>>.

Our OnePlus phone data will come from https://www.phonearena.com/phones/compare/OnePlus-5T,OnePlus-5,OnePlus-3T/phones/10695,10501,10313 .

== Node environment setup

You can skip this part if you are familiar with node.js environment setup as it's completely standard.

* install `node.js` and `npm` in your environment
* create a `tutorial` folder somewhere
* `npm init` and just accept whatever it says/asks
* `npm install freenlg` will download freenlg and end up with something like `+ freenlg@x.x.x`
* create an `tuto.js` file, just put `console.log("hello NLG");` inside of it
* `node tuto.js` should output `hello NLG` (PS that's not really Natural Language Generation yet)

== Initial data

Our initial data. Put it in your `tuto.js` file.
[source,javascript]
....
include::tuto.js[tags=data]
....

== Plumbing & first texts

You need the `freenlg` lib, thus, add this at the beginning of your `tuto.js` file:
[source,javascript]
....
include::tuto.js[tags=require]
....

In the same file, call a pug template (we will create the template just after):
[source,javascript]
....
var res = freenlgPug.renderFile('tuto.pug', {
    language: 'en_US',
    phone: phones[0]
});
console.log( res );
....
This will render the `tuto.pug` template. Parameters:

* choosing a language (here `language: 'en_US'`) is mandatory. 
* for the other properties you are free to organize them as you want; here we just put a `phone` property with our first phone.


Create a `tuto.pug` file with this content:
....
include::tuto_header.pug[]

p #{phone.name}
....
This first template is just standard Pug syntax: we output the name of the phone.
The first line `include ...main.pug` is mandatory for FreeNLG to work properly.

When you render the template (using `node tuto.js`) you should get: +
_<p>OnePlus 5T</p>_

_(ok, it's not really NLG yet)_


== Enumerations with the `foreach` mixin

Let's talk about the colors of the phone: we want to output _Available colors are aaa, bbb and ccc._

Create a mixin dedicated to listing colors (in your `tuto.pug` file):
....
mixin colors
  | the phone's available available colors are #[+foreach(phone.colors, null, { separator:',', last_separator:'and' })] .
....

* The `foreach` is a FreeNLG mixin. It's like a loop, with additionnal NLG features.
* `{ separator:',', last_separator:'and' }` tells the `foreach` mixin that the standard separator is the comma, and that `and` should be used between the two last ones.
* `null` simply indicates that we just want to output the value of each color ; you can reference a mixin when you want a specific output.

Call the mixin:
....
p #{phone.name} . #[+colors]
....

Run it. Output should be: _OnePlus 5T. The phone's available colors are Black, Red and White._

See how FreeNLG managed the spacing between words and the automatic capitalization. This is called "Surface Realization" in NLG.

TIP: Now we are doing Natural Language Generation ðŸš€


== Looping on all the phones

Let's generate some text for each phone. In your `tuto.js` file:
[source,javascript]
....
include::tuto.js[tags=mainLoop]
....

We could have had the main loop directly in your the pug template. Still, looping outside of the template allows an easy reset of FreeNLG, which is better for performance.

You should get: +
_<p>OnePlus 5T</p><p>The phone's available colors are Black, Red and White.</p>_ +
_<p>OnePlus 5</p><p>The phone's available colors are Gold and Gray.</p>_ +
_<p>OnePlus 3T</p><p>The phone's available colors are Black, Gold and Gray.</p>_


== Basic synonyms

Readers love when texts are not repetitive. Let's add some very basic synonyms: _tints_ and _tones_ are synonyms of _colors_.
Change your `colors` mixin:
....
mixin colors
  | the phone's available #[+syn('colors', 'tints', 'tones')]
  | are #[+foreach(phone.colors, null, { separator:',', last_separator:'and' })] .
....

Run it multiple times and you should have different outputs.

== More synonyms

The `syn` mixin is perfect for words or part of sentences. But let's say we want create some introduction texts, and that we want to have diversity.

Let's put all these different introductions in a dedicated mixin:
....
mixin intro
  synz
    syn
      | the #{phone.name} is really a fantastic phone.
    syn
      | i really love the new #{phone.name}.
    syn
      | #{phone.name} : a great phone !
....

The `synz > syn` structure simply lists synonymic alternatives. You can put whatever you want in each alternative (in each `syn`): conditions, more synonyms etc.

Let's call this new mixin:
....
mixin phone
  | #[+intro] .
  | #[+colors] .

p #[+phone]
....

You should get: +
_<p>I really love the new OnePlus 5T. The phone's available tints are Black, Red and White.</p>_ +
_<p>I really love the new OnePlus 5. The phone's available tints are Gold and Gray.</p>_ +
_<p>OnePlus 3T: a great phone! The phone's available tones are Black, Gold and Gray.</p>_

Intros are chosen randomly so you might have repetitions.

== List parts of a sentence

Let's talk about the display: physical size and screen-to-body ratio. We want to output something like _it has a a physical size of 6 inches and a a screen-to-body ratio of 80.43 %_.
We could build a big static sentence, but structuring the code will give us more flexibility.

Let's cut our big sentence in chunks, one for each property:
....
mixin display
  itemz { separator:',', last_separator:'and' }
    item
      | a physical size of #[+valWithUnit(phone.displaySize, 'inches')]
    item
      | a screen-to-body ratio of #[+valWithUnit(phone.screenRatio, '%')]
....

* `valWithUnit` is a very basic mixin that will output the value, a space, and the unit.
* `itemz > item` is much like `synz > syn`, except that it will not choose one alternative, but list all the items.
* The js object after `itemz` tells FreeNLG how to assemble elements. It is mandatory. `separator` and `last_separator` work exactly the same way as in the `foreach` mixin.

Do not forget to call this mixin:
....
mixin phone
  | #[+intro] .
  | #[+colors] .
  | #[+display] .
....

The result is not that bad, but the beginning of the text is missing. Let's fix that:
....
mixin display
  itemz { begin_with_general: 'it has a display', separator:',', last_separator:'and' }
    item
      | a physical size of #[+valWithUnit(phone.displaySize, 'inches')]
    item
      | a screen-to-body ratio of #[+valWithUnit(phone.screenRatio, '%')]
....

`begin_with_general` tells FreeNLG what the texts should begin with. You could have put it outside the mixin (just before), but it's a good practice to put them inside: for instance, when the list of the elements to enumerate is empty, FreeNLG will not output the `begin_with_general` content.


You should get better texts: +
_<p>The OnePlus 5T is really a fantastic phone. The phone's available tones are Black, Red and White. It has a display with a physical size of 6 inches and a screen-to-body ratio of 80.43 %.</p>_ +
_<p>OnePlus 5: a great phone! The phone's available tones are Gold and Gray. It has a display with a physical size of 5.5 inches and a screen-to-body ratio of 72.93 %.</p>_ +
_<p>OnePlus 3T: a great phone! The phone's available colors are Black, Gold and Gray. It has a display with a physical size of 5.5 inches and a screen-to-body ratio of 73.15 %.</p>_ +


You can add some diversity by randomly changing the order of the output by adding the `shuffle` parameter:
....
mixin display
  itemz { begin_with_general: 'it has a display', separator:',', last_separator:'and', shuffle:true }
    item
      | a physical size of #[+valWithUnit(phone.displaySize, 'inches')]
    item
      | a screen-to-body ratio of #[+valWithUnit(phone.screenRatio, '%')]
....

_<p>The OnePlus 5T is really a fantastic phone. The phone's available colors are Black, Red and White. It has a display with a screen-to-body ratio of 80.43 % and a physical size of 6 inches.</p>_ +
_<p>The OnePlus 5 is really a fantastic phone. The phone's available tints are Gold and Gray. It has a display with a physical size of 5.5 inches and a screen-to-body ratio of 72.93 %.</p>_ +
_<p>I really love the new OnePlus 3T. The phone's available colors are Black, Gold and Gray. It has a display with a physical size of 5.5 inches and a screen-to-body ratio of 73.15 %.</p>_

== Even more shuffle

First let's add text some about the battery:
....
  | this phone has a battery of #[+valWithUnit(phone.battery, 'mAh')] .
....

Now we have a decent volume of text. But we would like to have more variability: we always talk about colors, the display, and the battery, in this order, but it could be in any order. Let's put all our text chunks in an `itemz > item` structure, and add a `shuffle`:
....
mixin phone_chunks
  itemz {separator: '.', end:'.', shuffle:true}
    item
      | #[+colors]
    item
      | #[+display]
    item
      | this phone has a battery of #[+valWithUnit(phone.battery, 'mAh')]

include::tuto.pug[tags=phoneMixin]
....

== Anaphoras

There is a hidden structure behind the way we talk about the phone :

* The first time we talk about it we use the name of the phone.
* The next times we use either `the phone`, `it`, or `this phone`.

This is called _anaphoras_ in NLG. The first time we talk about something we use its _representant_ representation and after we use the _anaphora_ representation. We want FreeNLG to care for that automatically.

Let's create 2 mixins, one for each kind of representant:
....
mixin phone_ref(obj, params)
  | #{obj.name}

mixin phone_ana(obj, params)
  | #[+syn('the phone', 'this phone', 'it')]
....

TIP: The first parameter, `obj`, is the phone itself. `#{obj.name}` is exactly the same as `#{phone.name}`.

We also have to register them:
....
include::tuto.pug[tags=main]
....

Now we can use them everywhere:
....
mixin colors
  | #[+value(phone)]'s available #[+syn('colors', 'tints', 'tones')]
  | are #[+foreach(phone.colors, null, { separator:',', last_separator:'and' })] .

include::tuto.pug[tags=introMixin]
....

In the `phone_chunks` mixin:
....
      | #[+value(phone)] has a battery of #[+valWithUnit(phone.battery, 'mAh')]
....

We have to change the structure for the `it has a display with`, as we cannot put a `value` directly in the `begin_with_general` structure. It has to be a string or a mixin:
....
include::tuto.pug[tags=mixinItHasADisplay]
...
  itemz { begin_with_general: 'itHasADisplay', separator:',', last_separator:'and', shuffle:true }
....

This is what you should get: +
_<p>OnePlus 5T: a great phone! It has a display with a physical size of 6 inches and a screen-to-body ratio of 80.43 %. It has a battery of 3300 mAh. It's available tones are Black, Red and White.</p>_ +
_<p>I really love the new OnePlus 5. This phone has a display with a physical size of 5.5 inches and a screen-to-body ratio of 72.93 %. The phone has a battery of 3300 mAh. This phone's available tints are Gold and Gray.</p>_ +
_<p>The OnePlus 3T is really a fantastic phone. This phone's available colors are Black, Gold and Gray. It has a display with a physical size of 5.5 inches and a screen-to-body ratio of 73.15 %. This phone has a battery of 3400 mAh.</p>_


It's pretty decent, but there's one issue: you can trigger _It's available tones are_ which is wrong. It should be either _the phone's_, _this phone's_, or _its_.


== Conditional texts

We could use different techniques to address that, but a pretty straightforward solution is just to forbid the use of `it` at this specific place.

Let's add a flag when calling the anaphora: we just don't want _it_ to be triggered:
....
include::tuto.pug[tags=colorsMixinNotIt]
....

Now we have to:

* catch this flag in our anaphora mixin
* use the `synz > syn` structure instead of `syn` to be able to write the condition

....
mixin phone_ana(obj, params)
  synz
    syn
      | the phone
    syn
      | this phone
    syn
      if !hasFlag(params, 'NOT_IT')
        | it
....

Generate the texts and you should see that the _It's_ have disappeared.

TIP: When an empty synonym is triggered (which can happen here), FreeNLG will just choose another one.

Still we can have this kind of output: +
_<p>The OnePlus 5T is really a fantastic phone. This phone has a display with a screen-to-body ratio of 80.43 % and a physical size of 6 inches. This phone's available tints are Black, Red and White. This phone has a battery of 3300 mAh.</p>_

We have 3 times _This phone_ here which is not perfect. How could we avoid that?

== Change synonym mode

Instead of choosing synonyms randomly, we can just trigger them in sequence. This will avoid close repetitions:
....
mixin phone_ana(obj, params)
  synz 'sequence'
    syn
      ...
....

Now we should have less repetitions in our synonyms for the phone.


== Fancier sentences and "has said"

Let's generate a fancier sentence combining display size and battery capacity: _The phone has a display with a screen-to-body ratio of 73.15 % and a physical size of 5.5 inches along with a battery of 3400 mAh._

This is quite straightforward:
....
| #[+display]
| along with a battery of #[+valWithUnit(phone.battery, 'mAh')]
....

The problem is, _we don't want to talk about the battery twice_. We could just remove the standard battery sentence (_The phone has a battery of 3400 mAh_), but let's try to *trigger the battery sentence only if we have not talked about the battery before*. This is where `hasSaid` and `recordSaid` come in.

....
include::tuto.pug[tags=hasSaid]
....

The pattern hasSaid/recordSaid pattern, here is twice, is the following: _if we haven't talked about something:_

. _We talk about it_
. _We record that we talked about it_

TIP: You must use these built-in mechanisms and not rely on your own variables or hashmaps that you would set along text generation, as FreeNLG goes back and forth in the text rendering.

You should get those nice sentences:+
_<p>OnePlus 5T: a great phone! The phone has a battery of 3300 mAh. This phone's available tints are Black, Red and White. It has a display with a physical size of 6 inches and a screen-to-body ratio of 80.43 %.</p>_ +
_<p>OnePlus 5: a great phone! The phone has a battery of 3300 mAh. This phone has a display with a physical size of 5.5 inches and a screen-to-body ratio of 72.93 %. The phone's available colors are Gold and Gray.</p>_


== Congratulations!

*Sincere Congratulations!* ðŸŽ†

== Even more

We have gone through some aspects of NLG with this tutorial. 

There are some other features you can explore, for instance:

* automatic a / an : `a apple` => `an apple`, `a hour` => `an hour`
* agreement of verbs (especially the irregular ones)
* agreement of words: `tomato` => `tomatoes`
* etc.


== Final version of the code

`tuto.js`
[source,javascript]
....
include::tuto.js[]
....

`tuto.pug`
....
include::tuto_header.pug[]
include::tuto.pug[]
....
