= FreeNLG Tutorial

ifeval::["{outfilesuffix}" == ".html"]
link:tutorial_de_DE.pdf[PDF version]
endif::[]

ifndef::wholedoc[]
image::freenlg-logo.png[FreeNLG logo]
endif::[]

:freenlg_lang: de_DE


include::tuto_fragments.adoc[tags=intro;node_setup;initial_data;plumbing]


== List elements with the `eachz` structure

Let's talk about the colors of the phone: we want to output _Die verf√ºgbaren T√∂ne sind aaa, bbb und ccc._

Create a mixin dedicated to listing colors (in your `tuto.pug` file):
....
mixin colors
  | die verf√ºgbaren T√∂ne sind
  eachz color in phone.colors with { separator:',', last_separator:'und', end:'.' }
    | #{color}
....

* `eachz` is a FreeNLG structure. It's like a foreach loop, with additionnal NLG features.
* `{ separator:',', last_separator:'und', end:'.' }` tells `eachz` that:
** the standard separator is the comma
** `und` should be used between the two last colors
** we should end with a dot

Call the mixin:
....
p #{phone.name} . #[+colors]
....

Run it. Output should be: _OnePlus 5T. Die verf√ºgbaren T√∂ne sind Black, Red und White._

See how FreeNLG managed the spacing between words and the automatic capitalization. This is called "Surface Realization" in NLG.

TIP: Now we are doing Natural Language Generation üöÄ

It is better to have the names of the colors in German. Define the mapping:
....
mixin colors
  | die verf√ºgbaren T√∂ne sind
  eachz color in phone.colors with { separator:',', last_separator:'und', end:'.' }
    -
      var colorMapping = {
        'Black': 'Schwarz',
        'Red': 'Rot',
        'White': 'Wei√ü',
        'Gold': 'Gold',
        'Gray': 'Grau'
      }
    | #{colorMapping[color]}
....

The result must now be _OnePlus 5T. Die verf√ºgbaren T√∂ne sind Schwarz, Rot und Wei√ü._.


== Looping on all the phones

include::tuto_fragments.adoc[tags=looping]

You should get: +
_<p>OnePlus 5T. Die verf√ºgbaren T√∂ne sind Schwarz, Rot und Wei√ü.</p>_ +
_<p>OnePlus 5. Die verf√ºgbaren T√∂ne sind Gold und Grau.</p>_ +
_<p>OnePlus 3T. Die verf√ºgbaren T√∂ne sind Schwarz, Gold und Grau.</p>_ +


== Basic synonyms

Readers love when texts are not repetitive. Let's add some very basic synonyms: _Farben_ and _Farbt√∂ne_ are synonyms of _T√∂ne_.
Change your `colors` mixin:
....
mixin colors
  | die verf√ºgbaren #[+syn('Farben', 'Farbt√∂ne', 'T√∂ne')]
  | sind
  ...
....

Run it multiple times and you should have different outputs.

== More synonyms

The `syn` mixin is perfect for words or part of sentences. But let's say we want create some introduction texts, and that we want to have diversity.

Let's put all these different introductions in a dedicated mixin:
....
mixin intro
  synz
    syn
      | #{phone.name} ist wirklich ein fantastisches Telefon.
    syn
      | #{phone.name} : ein tolles Telefon !
....

The `synz > syn` structure simply lists synonymic alternatives. You can put whatever you want in each alternative (in each `syn`): conditions, more synonyms etc.

Let's call this new mixin:
....
mixin phone
  | #[+intro] .
  | #[+colors] .

p #[+phone]
....

You should get: +
_<p>OnePlus 5T: ein tolles Telefon! Die verf√ºgbaren Farbt√∂ne sind Schwarz, Rot und Wei√ü.</p>_ +
_<p>OnePlus 5 ist wirklich ein fantastisches Telefon. Die verf√ºgbaren Farbt√∂ne sind Gold und Grau.</p>_ +
_<p>OnePlus 3T: ein tolles Telefon! Die verf√ºgbaren Farben sind Schwarz, Gold und Grau.</p>_

Intros are chosen randomly so you might have repetitions.


== List parts of a sentence

Let's talk about the display: physical size and screen-to-body ratio. We want to output something like _das Telefon verf√ºgt √ºber ein Display mit einer physischen Gr√∂√üe von 6 Zoll und einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 80,43%._.
We could build a big static sentence, but structuring the code will give us more flexibility.

Let's cut our big sentence in chunks, one for each property:
....
mixin display
  itemz { separator:',', last_separator:'und' }
    item
      | einer physischen Gr√∂√üe von #[+value(phone.displaySize)] Zoll
    item
      | einem Bildschirm-zu-K√∂rper-Verh√§ltnis von #[+value(phone.screenRatio)]%
....

include::tuto_fragments.adoc[tag=display_elts]

The result is not that bad, but the beginning of the text is missing. Let's fix that:
....
mixin display
  itemz { begin_with_general: 'das Telefon verf√ºgt √ºber ein Display mit', separator:',', last_separator:'und' }
    item
      | einer physischen Gr√∂√üe von #[+value(phone.displaySize)] Zoll
    item
      | einem Bildschirm-zu-K√∂rper-Verh√§ltnis von #[+value(phone.screenRatio)]%
....


include::tuto_fragments.adoc[tag=begin_with_general_why]


You should get better texts: +
_<p>OnePlus 5T ist wirklich ein fantastisches Telefon. Die verf√ºgbaren Farbt√∂ne sind Schwarz, Rot und Wei√ü. Das Telefon verf√ºgt √ºber ein Display mit einer physischen Gr√∂√üe von 6 Zoll und einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 80,43%.</p>_ +
_<p>OnePlus 5 ist wirklich ein fantastisches Telefon. Die verf√ºgbaren Farbt√∂ne sind Gold und Grau. Das Telefon verf√ºgt √ºber ein Display mit einer physischen Gr√∂√üe von 5,5 Zoll und einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 72,93%.</p>_ +
_<p>OnePlus 3T: ein tolles Telefon! Die verf√ºgbaren Farbt√∂ne sind Schwarz, Gold und Grau. Das Telefon verf√ºgt √ºber ein Display mit einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 73,15% und einer physischen Gr√∂√üe von 5,5 Zoll.</p>_


You can add some diversity by randomly changing the order of the output by adding the `mix` parameter:
....
  itemz { begin_with_general: 'das Telefon verf√ºgt √ºber ein Display mit', separator:',', last_separator:'und', mix:true }
....

_<p>OnePlus 5T: ein tolles Telefon! Die verf√ºgbaren T√∂ne sind Schwarz, Rot und Wei√ü. Das Telefon verf√ºgt √ºber ein Display mit einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 80,43% und einer physischen Gr√∂√üe von 6 Zoll.</p>_ +
_<p>OnePlus 5 ist wirklich ein fantastisches Telefon. Die verf√ºgbaren Farben sind Gold und Grau. Das Telefon verf√ºgt √ºber ein Display mit einer physischen Gr√∂√üe von 5,5 Zoll und einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 72,93%.</p>_ +
_<p>OnePlus 3T ist wirklich ein fantastisches Telefon. Die verf√ºgbaren Farbt√∂ne sind Schwarz, Gold und Grau. Das Telefon verf√ºgt √ºber ein Display mit einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 73,15% und einer physischen Gr√∂√üe von 5,5 Zoll.</p>_


XXXXXXXX

== Even more variety

First let's add text some about the battery:
....
| das Telefon hat einen Akku von #[+value(phone.battery)] mAh
....

Now we have a decent volume of text. But we would like to have more variability: we always talk about colors, the display, and the battery, in this order, but it could be in any order. Let's put all our text chunks in an `itemz > item` structure, and add a `mix`:
....
mixin phone_chunks
  itemz {separator: '.', end:'.', mix:true}
    item
      | #[+colors]
    item
      | #[+display]
    item
      | das Telefon hat einen Akku von #[+value(phone.battery)] mAh

include::tuto_de_DE.pug[tags=phoneMixin]
....




XXXXXXXXXXXXXXXXXXXX

== Referring expressions

There is a hidden structure behind the way we talk about the phone :

* The first time we talk about it we use the name of the phone.
* The next times we use either `the phone`, `it`, or `this phone`.

This is called _referring expressions_ in NLG. The first time we talk about something we use its _representant_ representation and after we use the _referring expression_ representation. We want FreeNLG to care for that automatically.

Let's create 2 mixins, one for each kind of representant:
....
mixin phone_ref(obj, params)
  | #{obj.name}

mixin phone_re(obj, params)
  | #[+syn('the phone', 'this phone', 'it')]
....

TIP: The first parameter, `obj`, is the phone itself. `#{obj.name}` is exactly the same as `#{phone.name}`.

We also have to register them:
....
include::tuto_de_DE.pug[tags=main]
....

Now we can use them everywhere:
....
mixin colors
  | #[+value(phone)]'s available #[+syn('colors', 'tints', 'tones')]
  | are
  ...

include::tuto_de_DE.pug[tags=introMixin]
....

In the `phone_chunks` mixin:
....
      | #[+value(phone)] has a battery of #[+value(phone.battery)] mAh
....

We have to change the structure for the `it has a display with`, as we cannot put a `value` directly in the `begin_with_general` structure. It has to be a string or a mixin:
....
include::tuto_de_DE.pug[tags=mixinItHasADisplay]
...
  itemz { begin_with_general: 'itHasADisplay', separator:',', last_separator:'and', mix:true }
....

This is what you should get: +
_<p>OnePlus 5T: a great phone! It has a display with a physical size of 6 inches and a screen-to-body ratio of 80.43 %. It has a battery of 3300 mAh. It's available tones are Black, Red and White.</p>_ +
_<p>I really love the new OnePlus 5. This phone has a display with a physical size of 5.5 inches and a screen-to-body ratio of 72.93 %. The phone has a battery of 3300 mAh. This phone's available tints are Gold and Gray.</p>_ +
_<p>The OnePlus 3T is really a fantastic phone. This phone's available colors are Black, Gold and Gray. It has a display with a physical size of 5.5 inches and a screen-to-body ratio of 73.15 %. This phone has a battery of 3400 mAh.</p>_


It's pretty decent, but there's one issue: you can trigger _It's available tones are_ which is wrong. It should be either _the phone's_, _this phone's_, or _its_.


== Conditional texts

We could use different techniques to address that, but a pretty straightforward solution is just to forbid the use of `it` at this specific place.

Let's add a flag when calling the referring expression: we just don't want _it_ to be triggered:
....
include::tuto_de_DE.pug[tags=colorsMixinNotIt]
....

Now we have to:

* catch this flag in our referring expression mixin
* use the `synz > syn` structure instead of `syn` to be able to write the condition

....
mixin phone_re(obj, params)
  synz
    syn
      | the phone
    syn
      | this phone
    syn
      if !hasFlag(params, 'NOT_IT')
        | it
....

Generate the texts and you should see that the _It's_ have disappeared.

TIP: When an empty synonym is triggered (which can happen here), FreeNLG will just choose another one.

Still we can have this kind of output: +
_<p>The OnePlus 5T is really a fantastic phone. This phone has a display with a screen-to-body ratio of 80.43 % and a physical size of 6 inches. This phone's available tints are Black, Red and White. This phone has a battery of 3300 mAh.</p>_

We have 3 times _This phone_ here which is not perfect. How could we avoid that?

== Change synonym mode

Instead of choosing synonyms randomly, we can just trigger them in sequence. This will avoid close repetitions:
....
mixin phone_re(obj, params)
  synz {mode:'sequence'}
    syn
      ...
....

Now we should have less repetitions in our synonyms for the phone.


== Fancier sentences and "has said"

Let's generate a fancier sentence combining display size and battery capacity: _The phone has a display with a screen-to-body ratio of 73.15 % and a physical size of 5.5 inches along with a battery of 3400 mAh._

This is quite straightforward:
....
| #[+display]
| along with a battery of #[+value(phone.battery)] mAh
....

The problem is, _we don't want to talk about the battery twice_. We could just remove the standard battery sentence (_The phone has a battery of 3400 mAh_), but let's try to *trigger the battery sentence only if we have not talked about the battery before*. This is where `hasSaid` and `recordSaid` come in.

....
include::tuto_de_DE.pug[tags=hasSaid]
....

The pattern hasSaid/recordSaid pattern, here used twice, is the following: _if we haven't talked about something:_

. _We talk about it_
. _We record that we talked about it_

TIP: You must use these built-in mechanisms and not rely on your own variables or hashmaps that you would set along text generation, as FreeNLG goes back and forth in the text rendering.

You should get those nice sentences:+
_<p>OnePlus 5T: a great phone! The phone has a battery of 3300 mAh. This phone's available tints are Black, Red and White. It has a display with a physical size of 6 inches and a screen-to-body ratio of 80.43 %.</p>_ +
_<p>OnePlus 5: a great phone! The phone has a battery of 3300 mAh. This phone has a display with a physical size of 5.5 inches and a screen-to-body ratio of 72.93 %. The phone's available colors are Gold and Gray.</p>_


include::tuto_fragments.adoc[tag=congrats]

== Even more

We have gone through some aspects of NLG with this tutorial. 

There are some other features you can explore, for instance:

* automatic a / an : `a apple` => `an apple`, `a hour` => `an hour`
* agreement of verbs (especially the irregular ones)
* agreement of words: `tomato` => `tomatoes`
* etc.


== Final version of the code

`tuto.js`
[source,javascript]
....
include::tuto_fragments.js[tags=require]
include::tuto_fragments.js[tags=data]
include::tuto_fragments.js[tags=mainLoop_de_DE]
....

`tuto.pug`
....
include::tuto_de_DE.pug[]
....
