= FreeNLG Tutorial

ifeval::["{outfilesuffix}" == ".html"]
link:tutorial_de_DE.pdf[PDF version]
endif::[]

ifndef::wholedoc[]
image::freenlg-logo.png[FreeNLG logo]
endif::[]

:freenlg_lang: de_DE


include::tuto_fragments.adoc[tags=intro;node_setup;initial_data;plumbing]


== List elements with the `eachz` structure

Let's talk about the colors of the phone: we want to output _Die verf√ºgbaren T√∂ne des Telefons sind aaa, bbb und ccc._

Create a mixin dedicated to listing colors (in your `tuto.pug` file):
....
mixin colors
  | die verf√ºgbaren T√∂ne des Telefons sind
  eachz color in phone.colors with { separator:',', last_separator:'und', end:'.' }
    | #{color}
....

* `eachz` is a FreeNLG structure. It's like a foreach loop, with additionnal NLG features.
* `{ separator:',', last_separator:'und', end:'.' }` tells `eachz` that:
** the standard separator is the comma
** `und` should be used between the two last colors
** we should end with a dot

Call the mixin:
....
p #{phone.name} . #[+colors]
....

Run it. Output should be: _OnePlus 5T. Die verf√ºgbaren T√∂ne des Telefons sind Black, Red und White._

See how FreeNLG managed the spacing between words and the automatic capitalization. This is called "Surface Realization" in NLG.

TIP: Now we are doing Natural Language Generation üöÄ

It is better to have the names of the colors in German. Define the mapping:
....
mixin colors
  | die verf√ºgbaren T√∂ne des Telefons sind
  eachz color in phone.colors with { separator:',', last_separator:'und', end:'.' }
    -
      var colorMapping = {
        'Black': 'Schwarz',
        'Red': 'Rot',
        'White': 'Wei√ü',
        'Gold': 'Gold',
        'Gray': 'Grau'
      }
    | #{colorMapping[color]}
....

The result must now be _OnePlus 5T. Die verf√ºgbaren T√∂ne des Telefons sind Schwarz, Rot und Wei√ü._.


== Looping on all the phones

include::tuto_fragments.adoc[tags=looping]

You should get: +
_<p>OnePlus 5T. Die verf√ºgbaren T√∂ne des Telefons sind Schwarz, Rot und Wei√ü.</p>_ +
_<p>OnePlus 5. Die verf√ºgbaren T√∂ne des Telefons sind Gold und Grau.</p>_ +
_<p>OnePlus 3T. Die verf√ºgbaren T√∂ne des Telefons sind Schwarz, Gold und Grau.</p>_ +


== Basic synonyms

Readers love when texts are not repetitive. Let's add some very basic synonyms: _Farben_ and _Farbt√∂ne_ are synonyms of _T√∂ne_.
Change your `colors` mixin:
....
mixin colors
  | die verf√ºgbaren #[+syn('Farben', 'Farbt√∂ne', 'T√∂ne')]
  | des Telefons sind
  ...
....

Run it multiple times and you should have different outputs.

== More synonyms

The `syn` mixin is perfect for words or part of sentences. But let's say we want create some introduction texts, and that we want to have diversity.

Let's put all these different introductions in a dedicated mixin:
....
mixin intro
  synz
    syn
      | der #{phone.name} ist wirklich ein fantastisches Telefon.
    syn
      | ich liebe den neuen #{phone.name}.
    syn
      | der #{phone.name} : ein tolles Telefon !
....

The `synz > syn` structure simply lists synonymic alternatives. You can put whatever you want in each alternative (in each `syn`): conditions, more synonyms etc.

Let's call this new mixin:
....
mixin phone
  | #[+intro] .
  | #[+colors] .

p #[+phone]
....

You should get: +
_<p>Der OnePlus 5T: ein tolles Telefon! Die verf√ºgbaren Farbt√∂ne des Telefons sind Schwarz, Rot und Wei√ü.</p>_ +
_<p>Der OnePlus 5 ist wirklich ein fantastisches Telefon. Die verf√ºgbaren Farbt√∂ne des Telefons sind Gold und Grau.</p>_ +
_<p>Ich liebe den neuen OnePlus 3T. Die verf√ºgbaren Farben des Telefons sind Schwarz, Gold und Grau.</p>_

Intros are chosen randomly so you might have repetitions.


== List parts of a sentence

Let's talk about the display: physical size and screen-to-body ratio. We want to output something like _das Telefon verf√ºgt √ºber ein Display mit einer physischen Gr√∂√üe von 6 Zoll und einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 80,43%._.
We could build a big static sentence, but structuring the code will give us more flexibility.

Let's cut our big sentence in chunks, one for each property:
....
mixin display
  itemz { separator:',', last_separator:'und' }
    item
      | einer physischen Gr√∂√üe von #[+value(phone.displaySize)] Zoll
    item
      | einem Bildschirm-zu-K√∂rper-Verh√§ltnis von #[+value(phone.screenRatio)]%
....

include::tuto_fragments.adoc[tag=display_elts]

The result is not that bad, but the beginning of the text is missing. Let's fix that:
....
mixin display
  itemz { begin_with_general: 'das Telefon verf√ºgt √ºber ein Display mit', separator:',', last_separator:'und' }
    item
      | einer physischen Gr√∂√üe von #[+value(phone.displaySize)] Zoll
    item
      | einem Bildschirm-zu-K√∂rper-Verh√§ltnis von #[+value(phone.screenRatio)]%
....


include::tuto_fragments.adoc[tag=begin_with_general_why]


You should get better texts: +
_<p>Der OnePlus 5T ist wirklich ein fantastisches Telefon. Die verf√ºgbaren Farbt√∂ne des Telefons sind Schwarz, Rot und Wei√ü. Das Telefon verf√ºgt √ºber ein Display mit einer physischen Gr√∂√üe von 6 Zoll und einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 80,43%.</p>_ +
_<p>Der OnePlus 5 ist wirklich ein fantastisches Telefon. Die verf√ºgbaren Farbt√∂ne des Telefons sind Gold und Grau. Das Telefon verf√ºgt √ºber ein Display mit einer physischen Gr√∂√üe von 5,5 Zoll und einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 72,93%.</p>_ +
_<p>Ich liebe den neuen OnePlus 3T. Die verf√ºgbaren Farbt√∂ne des Telefons sind Schwarz, Gold und Grau. Das Telefon verf√ºgt √ºber ein Display mit einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 73,15% und einer physischen Gr√∂√üe von 5,5 Zoll.</p>_


You can add some diversity by randomly changing the order of the output by adding the `mix` parameter:
....
  itemz { begin_with_general: 'das Telefon verf√ºgt √ºber ein Display mit', separator:',', last_separator:'und', mix:true }
....

_<p>Der OnePlus 5T: ein tolles Telefon! Die verf√ºgbaren T√∂ne des Telefons sind Schwarz, Rot und Wei√ü. Das Telefon verf√ºgt √ºber ein Display mit einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 80,43% und einer physischen Gr√∂√üe von 6 Zoll.</p>_ +
_<p>Der OnePlus 5 ist wirklich ein fantastisches Telefon. Die verf√ºgbaren Farben des Telefons sind Gold und Grau. Das Telefon verf√ºgt √ºber ein Display mit einer physischen Gr√∂√üe von 5,5 Zoll und einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 72,93%.</p>_ +
_<p>Ich liebe den neuen OnePlus 3T. Die verf√ºgbaren Farbt√∂ne des Telefons sind Schwarz, Gold und Grau. Das Telefon verf√ºgt √ºber ein Display mit einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 73,15% und einer physischen Gr√∂√üe von 5,5 Zoll.</p>_


== Even more variety

First let's add text some about the battery:
....
| das Telefon hat einen Akku von #[+value(phone.battery)] mAh
....

Now we have a decent volume of text. But we would like to have more variability: we always talk about colors, the display, and the battery, in this order, but it could be in any order. Let's put all our text chunks in an `itemz > item` structure, and add a `mix`:
....
mixin phone_chunks
  itemz {separator: '.', end:'.', mix:true}
    item
      | #[+colors]
    item
      | #[+display]
    item
      | das Telefon hat einen Akku von #[+value(phone.battery)] mAh

include::tuto_de_DE.pug[tags=phoneMixin]
....


== Referring expressions

There is a hidden structure behind the way we talk about the phone :

* The first time we talk about it we use the name of the phone.
* The next times we use `das Telefon`. But we also could say `dieses Telefon`, `das Handy`, or `die Gurke` (and also use pronouns `er` `sie` `es`).

include::tuto_fragments.adoc[tag=refexpr_concept]

Let's create 2 mixins, one for each kind of representant:
....
mixin phone_ref(obj, params)
  | #{obj.name}

mixin phone_refexpr(obj, params)
  | #[+syn('das Telefon', 'dieses Telefon', 'das Handy', 'es')]
....

TIP: The first parameter, `obj`, is the phone itself. `#{obj.name}` is exactly the same as `#{phone.name}`.

We also have to register them:
....
include::tuto_de_DE.pug[tags=main]
....

Now we can use them everywhere:
....
      | #[+value(phone)] ist wirklich ein fantastisches Telefon.

      | #[+value(phone)] : ein tolles Telefon !

      | #[+value(phone)] hat einen Akku von #[+value(phone.battery)] mAh
....

We have to change the structure for the `das Telefon verf√ºgt √ºber ein Display mit`, as we cannot put a `value` directly in the `begin_with_general` structure. It has to be a string or a mixin:
....
include::tuto_de_DE.pug[tags=mixinItHasADisplay]
...
  itemz { begin_with_general: 'itHasADisplay', separator:',', last_separator:'und', mix:true }
....

This is what you should get: +
_<p>Der OnePlus 5T: ein tolles Telefon! Dieses Telefon verf√ºgt √ºber ein Display mit einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 80,43% und einer physischen Gr√∂√üe von 6 Zoll. Es hat einen Akku von 3 300 mAh. Die verf√ºgbaren T√∂ne des Telefons sind Schwarz, Rot und Wei√ü.</p>_ +
_<p>Ich liebe den neuen OnePlus 5. Der OnePlus 5 hat einen Akku von 3 300 mAh. Das Handy verf√ºgt √ºber ein Display mit einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 72,93% und einer physischen Gr√∂√üe von 5,5 Zoll. Die verf√ºgbaren T√∂ne des Telefons sind Gold und Grau.</p>_ +
_<p>Der OnePlus 3T: ein tolles Telefon! Die verf√ºgbaren Farben des Telefons sind Schwarz, Gold und Grau. Das Telefon verf√ºgt √ºber ein Display mit einer physischen Gr√∂√üe von 5,5 Zoll und einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 73,15%. Es hat einen Akku von 3 400 mAh.</p>_

It's pretty decent, but there are 3 issues (depending on the triggered synonyms combination):
. We have not been able to replace `ich liebe den neuen #{phone.name}`, because the article (`den`) is already present before the `neuen` adjective. It's not a big issue, but this may issue in these texts: _Ich liebe den neuen OnePlus 5. Der OnePlus 5 hat einen Akku von 3 300 mAh._
. We have not been able to replace `des Telefons` because it's genitive case.

There are various more or less sophisticated approaches to solve the first issue. A first direct approach is to use parameters and conditions.

The second issue will be solved quite later in the tutorial.


== Conditional texts

We could use different techniques to address the first issue, but a pretty straightforward solution is just to remove `der` when the representant is called in this specific context.

Let's add a flag when calling the value of phone: we just don't want the determinant to be present:
....
      | ich liebe den neuen #[+value(phone, {'NO_DET':true})].
....

Now we have to catch this flag in our representant mixin:
....
  if !hasFlag(params,'NO_DET')
    | der
    |
  | #{obj.name}
....

INFO: The empty line containing only a pipe `|` forces the insertion of a space. If you don't put it, you will have `derOnePlus`. It is difficult to anticipate those cases - simply add a `|` in an empty line when it happens.

Generate the texts and you should see that the very first issue is solved: _Ich liebe den neuen OnePlus 5. Die Gurke hat einen Akku von 3 300 mAh._


== Fancier sentences and "has said"

Let's generate a fancier sentence combining display size and battery capacity: _Dieses Telefon verf√ºgt √ºber ein Display mit einer physischen Gr√∂√üe von 5,5 Zoll und einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 73,15% sowie einem Akku von 3 400 mAh._

This is quite straightforward:
....
| #[+display]
| sowie einem Akku von #[+value(phone.battery)] mAh
....

The problem is, _we don't want to talk about the battery twice_. We could just remove the standard battery sentence (_Das Handy hat einen Akku von 3 300 mAh_), but let's try to *trigger the battery sentence only if we have not talked about the battery before*. This is where `hasSaid` and `recordSaid` come in.

....
include::tuto_de_DE.pug[tags=hasSaid]
....

include::tuto_fragments.adoc[tag=has_said_solution]

You should get those nice sentences:+
_<p>Der OnePlus 5T ist wirklich ein fantastisches Telefon. Die verf√ºgbaren Farbt√∂ne des Telefons sind Schwarz, Rot und Wei√ü. Dieses Telefon hat einen Akku von 3 300 mAh. Das Telefon verf√ºgt √ºber ein Display mit einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 80,43% und einer physischen Gr√∂√üe von 6 Zoll.</p>_ +
_<p>Der OnePlus 5 ist wirklich ein fantastisches Telefon. Die verf√ºgbaren T√∂ne des Telefons sind Gold und Grau. Das Handy hat einen Akku von 3 300 mAh. Das Handy verf√ºgt √ºber ein Display mit einer physischen Gr√∂√üe von 5,5 Zoll und einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 72,93%.</p>_ +
_<p>Ich liebe den neuen OnePlus 3T. Die verf√ºgbaren Farbt√∂ne des Telefons sind Schwarz, Gold und Grau. Die Gurke verf√ºgt √ºber ein Display mit einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 73,15% und einer physischen Gr√∂√üe von 5,5 Zoll sowie einem Akku von 3 400 mAh.</p>_


== Even more referential expressions

We can generate _das Telefon_, _dieses Telefon_ and _das Handy_ as referential expressions. Let's add _die Gurke_ or _diese Gurke_.

It is easy to add synonyms in the list:
....
  synz
    syn
      | das Telefon
    syn
      | dieses Telefon
    syn
      | das Handy
    syn
      | die Gurke
    syn
      | diese Gurke
    syn
      | es
....

INFO: Replace the `+syn` function by a `synz > syn` structur for readibily, and also to add more stuff in each alternative - as we will do.

The issue is, _die Gurke_ is feminine! You will end up with texts like . _Die Gurke hat einen Akku von 3 400 mAh. Es verf√ºgt √ºber ein Display..._ which are not correct. We need to have `sie` instead of `es`. More generally, we need yo be able to follow the _current gender_ of the referential expression.


=== Explicit gender

A first method is to explicitely indicate the gender with `setRefGender`. `setRefGender` indicated FreeNLG the current gender of the object:
....
    syn
      | das Telefon
      - setRefGender(phone, 'N');
    syn
      | dieses Telefon
      - setRefGender(phone, 'N');
    syn
      | das Handy
      - setRefGender(phone, 'N');
    syn
      | die Gurke
      - setRefGender(phone, 'F');
    syn
      | diese Gurke
      - setRefGender(phone, 'F');
....

We can then get the current gender of the referential expression with `getRefGender`:
....
    syn
      if getRefGender(phone)=='F'
        | sie
      else
        | es
....

We should also explicitelu set the gender of the representant:
....
mixin phone_ref(obj, params)
  if !hasFlag(params,'NO_DET')
    | der
    |
  | #{obj.name}
  - setRefGender(phone, 'N');
....

Now the gender agreements are respected: _ Diese Gurke hat einen Akku von 3 400 mAh. Sie verf√ºgt √ºber ein Display..._.

The `getRefGender` structure trigerring _er_ _sie_ _es_ is very classic and there is a shortcut:
....
    syn
      | #{getMorF(['er', 'sie', 'es'], phone)}
....


=== Gender via dictionnary

Setting the gender manually is error prone. It is better to use FreeNLG's integrated dictionnary (derived from `german-pos-dict`):

....
    syn
      | dieses Telefon
      - setRefGender(phone, 'Telefon');
    syn
      | das Handy
      - setRefGender(phone, 'Handy');
....

There is a syntactic shortcut to:

. write a word
. look for its gender in the dictionnary
. save its current gender

....
    syn
      | das #[+value('Telefon', {represents: phone})]
    syn
      | dieses #[+value('Telefon', {represents: phone})]
    syn
      | das #[+value('Handy', {represents: phone})]
    syn
      | die #[+value('Gurke', {represents: phone})]
    syn
      | diese #[+value('Gurke', {represents: phone})]
    syn
      | #{getMorF(['er', 'sie', 'es'], phone)}
....


== Automatic determinant

Let's generate automatically the determiner. diese/dieses are demonstrative pronous, das/die are definite articles:
....
    syn
      | #[+value('Telefon', {represents: phone, det: 'DEFINITE'})]
    syn
      | #[+value('Telefon', {represents: phone, det: 'DEMONSTRATIVE'})]
    syn
      | #[+value('Handy', {represents: phone, det: 'DEFINITE'})]
    syn
      | #[+value('Gurke', {represents: phone, det: 'DEFINITE'})]
    syn
      | #[+value('Gurke', {represents: phone, det: 'DEMONSTRATIVE'})]
....

It is not essential, but we can easily mutualize alternatives using `syn_fct`. `syn_fct` is a function that randomly chooses an element from table:
....
    syn
      | #[+value('Telefon', {represents: phone, det: syn_fct(['DEFINITE','DEMONSTRATIVE'])})]
    syn
      | #[+value('Handy', {represents: phone, det: syn_fct(['DEFINITE','DEMONSTRATIVE'])})]
    syn
      | #[+value('Gurke', {represents: phone, det: syn_fct(['DEFINITE','DEMONSTRATIVE'])})]
....


== Genitive case

At last, let's solve our second issue. We were not able to replace `des Telefons` because it's genitive case. FreeNLG is able to manage cases in German (well, some of it at least) - but it needs to know both the current gender and the case. Current gender has been coped with just before, let's adress the case.

First, we must explicitely indicate that the case is genitive:
....
  | die verf√ºgbaren #[+syn('Farben', 'Farbt√∂ne', 'T√∂ne')]
  | #[+value(phone, {case:'GENITIVE'})]
  | sind
....

Second, we must convey this `case` param in the `value` mixin:
....
    syn
      | #[+value('Telefon', {represents: phone, det: syn_fct(['DEFINITE','DEMONSTRATIVE']), case: getFlagValue(params, 'case')})]
    syn
      | #[+value('Handy', {represents: phone, det: syn_fct(['DEFINITE','DEMONSTRATIVE']), case: getFlagValue(params, 'case')})]
    syn
      | #[+value('Gurke', {represents: phone, det: syn_fct(['DEFINITE','DEMONSTRATIVE']), case: getFlagValue(params, 'case')})]
....

`getFlagValue` is a shortcut to `params!=null && params.case!=null ? params.case : null`. The syntax is still heavy - we'll improve that later.

You will not have those kind of texts: _Die verf√ºgbaren Farbt√∂ne dieser Gurke_, _Die verf√ºgbaren Farben des Handys_. It is quite good, but you also get _Die verf√ºgbaren Farbt√∂ne sie sind Schwarz, Rot und Wei√ü._ We should not trigger the pronoun representation here.

Let's solve it with a flag as before:
....
  | #[+value(phone, {'NOT_ES':true, case:'GENITIVE'})]
....
and
....
    syn
      if !hasFlag(params, 'NOT_ES')
        | #{getMorF(['er', 'sie', 'es'], phone)}
....

include::tuto_fragments.adoc[tag=empty_synonym]

== Syntax improvements

When our `phone_ref` and `phone_refexpr` mixins receive information in `params`, they sometimes use it (like for `NOT_ES`) or simply transmit it to `value` (like for `case`). 

Some javascript magic will help:
....
mixin phone_ref(obj, params)
  - var det = hasFlag(params,'NO_DET') ? null : 'DEFINITE';
  | #[+value(obj.name, Object.assign({represents: phone, det: det, gender:'N'}, params))]

mixin valueProdukt(word, det, params)
  | #[+value(word, Object.assign({represents: phone, 'det': det}, params))]

mixin phone_refexpr(obj, params)
  synz
    syn
      if !hasFlag(params, 'NOT_ES')
        | #{getMorF(['er', 'sie', 'es'], phone)}
    syn
      | #[+valueProdukt('Gurke', syn_fct(['DEFINITE','DEMONSTRATIVE']), params)]
    syn
      | #[+valueProdukt('Handy', syn_fct(['DEFINITE','DEMONSTRATIVE']), params)]
    syn
      | #[+valueProdukt('Telefon', syn_fct(['DEFINITE','DEMONSTRATIVE']), params)]
....


== Change synonym mode

We sometimes have this kind of output: _Dieses Telefon hat einen Akku von 3 300 mAh. Dieses Telefon verf√ºgt √ºber ein Display mit einem Bildschirm-zu-K√∂rper-Verh√§ltnis von 72,93% und einer physischen Gr√∂√üe von 5,5 Zoll. Die verf√ºgbaren Farbt√∂ne dieses Telefons sind Gold und Grau._

We have 3 times _Telefon_ here which is not perfect. How could we avoid that?

Instead of choosing synonyms randomly, we can just trigger them in sequence. This will avoid close repetitions:
....
mixin phone_refexpr(obj, params)
  synz {mode:'sequence'}
    syn
      ...
....

Now we should have less repetitions in our synonyms for the phone.

include::tuto_fragments.adoc[tag=congrats]

== Even more

We have gone through some aspects of NLG with this tutorial. 

There are some other features you can explore, like numbers and dates formatting.


== Final version of the code

`tuto.js`
[source,javascript]
[subs=attributes+]
....
include::tuto_fragments.js[tags=require]
include::tuto_fragments.js[tags=data]
include::tuto_fragments.js[tags=mainLoop]
....

`tuto.pug`
....
include::tuto_de_DE.pug[]
....
