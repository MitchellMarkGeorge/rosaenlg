= FreeNLG Documentation

ifeval::["{outfilesuffix}" == ".html"]
link:index.pdf[PDF version]
endif::[]

image::freenlg-logo.png[FreeNLG logo]

== Intro

FreeNLG is a Natural Language Generation library for node.js, based on the https://pugjs.org/[Pug] template engine.

Supported languages are English and French.

FreeNLG is complete enough to write real life NLG applications.

* <<quick_start>>
* <<tutorial.adoc#, Tutorial>>
* <<mixins_ref.adoc#, Reference documentation>>.
* <<changelog.adoc#, Changelog / release note>>.
* If you wonder: <<what_is_nlg>> and <<usecases>>.
* <<dev.adoc#, Developer doc is here if you wish to contribute>>


anchor:quick_start[Quick start]

== Quick start

In some js file:
....
const freenlgPug = require('freenlg');

console.log( freenlgPug.renderFile('testNLG.pug', {
    language: 'en_US',
    data: ['apples', 'bananas', 'apricots']
}) );
....

In a `testNLG.pug` file:
....
test
  eachz fruit in data with { separator: ',', last_separator: 'and' }
    | #{fruit}
....

This will output `<test>apples, bananas and apricots</test>`.

Parameters when rendering the template are (along Pug's standard parameters):

* `language`: the output language (mandatory): `fr_FR` or `en_US`
* `forceRandomSeed`: the random seed (optionnal) - see <<seeds>>
* `loadDicts`: put `false` if you don't want to load linguistic resources (defaults to `true`) ; see <<resources>>
* `defaultSynoMode`: put `sequence` if you want synonyms to be sequence based by default ; `random` is the default value - see <<mixins_ref.adoc#synonyms_mode>>
* put `noFilter` to `true` (default is `false`) if don't want to automatically filter the whole outputs - more on this later


== Reference documentation

<<mixins_ref.adoc#,Mixings reference documentation>>


== Tutorial

<<tutorial.adoc#,Tutorial>>


anchor:what_is_nlg[What is NLG]

== What is NLG

NLG stands for _Natural Language Generation_. The goal of NLG is to generate texts automatically from data, with the same quality as if a human beeing had written it.

Natural Language Understanding (NLU) is the exact opposite: transforming text into structured data. NLG and NLU are both subfields of Natural Language Processing (NLP).

You don't need a Natural Language Generator to generate basic texts, but doing it without a Natural Language Generator quickly becomes tricky. The pratical issues in NLG are:

* the use of synonyms and anaphoras to avoid repetitions
* the proper agreement of verbs, nouns, adjectives (depending on the output language)
* proper punctuation and spacing
* the ability to properly _list_ things (_xxx, yyy and zzz_)

anchor:usecases[Usecases for NLG]

== What are the usecases for NLG

NLG automates the production of repetitive reports and texts based on structured data. For instance:

* describe a product and its features based on its characteristics
* produce structured reports in the banking/financial industry e.g. risk reports, financial fund performance
* summarize situations e.g. preparation to meeting, meeting minutes
* generate personalized emails
* generate training data for NLU and chatbots


anchor:how[How it works]

== How it works

FreeNLG consists of some specific Pug mixins with some algorithms in the background.

It generates texts in 2 distinct steps:

. A first output is generated via the standard Pug rendering system. See <<about_pug>>.
. This output is cleaned for proper punctuation. See <<filter_mechanism>>.


anchor:about_pug[Pug and Why pug]

== Pug & Why pug

A classic templating engine is a good basis to build a NLG system (at least for template-based NLG systems). It brings the ability to easily build html/xml structures, which is handy even when doing NLG, and brings out of the box features like conditions, switch/case etc. which are essential too in a NLG system.

https://pugjs.org/[Pug] is a node.js templating engine. It is fast, robust and feature-rich - and I like the syntax.

Thus FreeNLG is based on pug.

*FreeNLG templates are basically pug templates where you use FreeNLG structures and mixins to complete the standard pug syntax.*

FreeNLG templates make a heavy use of those pug structures:

* if / else
* case / when
* mixins
* inline javascript (with `-`)

Also, there is generally not that much html/xml structure in NLG templates ; texts are rather produced as a flow, which means that a you FreeNLG templates will make a heavy use of `|` and often look like that:
....
  | #[+callAMixin] bla
  | some text
  | #[+callAnotherMixin] etc.
....

Some nice pug documentation:

* http://markade.il.ly/docs/pug.html
* https://pugjs.org/language/mixins.html
* https://codeburst.io/getting-started-with-pug-template-engine-e49cfa291e33
* https://www.sitepoint.com/jade-tutorial-for-beginners/


anchor:filter_mechanism[Filter mechanism]

== Filter mechanism

After the NLG text is generated by pug and FreeNLG, you most often have various small defects in your texts regarding spacing, capitalization and punctuation.

While you could put extra care in your NLG templates to avoid these defects, we think that this is tedious and that the cleaning task can be automated. Thus, once the NLG text is generated, just call a filtering function to clean your texts.
To do it, see <<ref_filter.adoc, Filter mixins and functions>>.

.Filtering examples
[options="header"]
|=====================================================================
| Type | Original string => After filtering
| capitalization | `bla.bla` => `bla. Bla`
| remove extra spacing | `word1  word2` => `word1 word2`
| remove doubled punctuation | `..` => `.`
| contractions (in French) | `de un` => `d'un`, `de à côté` => `d'à côté`, `des les` => `des`
| a / an | `a apple` => `an apple`, `a hour` => `an hour` (using `compromise` lib)
|=====================================================================


anchor:resources[Linguistic resources]

== Linguistic resources

Depending on the output language, FreeNLG will load some linguistic resources or use linguistic libraries, to make agreements and to conjugate verbs.
Static resources are a bunch of JSON files in the `resources_pub` folder. They are built from public linguist resources and carry their own licence.

What is currently loaded/used, depending on the language:

* `fr_FR`: 
** will load a file to get the gender of substantives (_la couleur_ / _le poids_ etc.)
** `format-number-french` to format numbers
** `jslingua` to conjugate verbs
** `pluralize-fr` to pluralize nouns
* `en_US`: uses the `compromise` lib. This great lib can also be accessed directly via `util.compromise`. It is used to pluralize nouns, to format numbers, to output cardinal and ordinal numbers, and for conjugation.


anchor:random_numbers[About random numbers]

== About random numbers

=== Why it matters

FreeNLG uses random numbers to choose synonymic alternatives, to choose synonyms and anaphoras. The following features uses random numbers:

** Synonyms: see <<synonyms>>
* the `syn` mixin
* the `syno_sentences` mixin
* the `synz` / `syn` structure
* the `syn_fct` function
* the `assemble` mixin and the `itemz` / `item` structure when shuffle is set to true

Also, FreeNLG has to be able to "predict the future": for instance it runs synonymic alternatives just to test if they are empty or not - but without actually keeping them. It also runs anaphoras to check their gender and number, before they are triggered for real.

Once the result of these predictions are known, FreeNLG rollbacks and continues the actual text generation. But when it actually generates the content that was previously predicted, it must produce the same content as predicted: *thus it must have the same random numbers*.

This means that FreeNLG does not really generate random numbers on the fly:

* When FreeNLG is initialiazed (when `renderFile` is called for instance), it creates an array of random numbers for its own use
* During text generation, it uses this array to get random numbers
* When it rollbacks after a prediction, it also rollbacks the current position in this array

You must not use random numbers in text generation otherwise it will confuse FreeNLG's prediction system.

anchor:seeds[random seeds]

=== Seeds

When rendering a FreeNLG template, you can set the `forceRandomSeed` parameter. If set, FreeNLG will use this random seed. If not set, it will just randomly choose one.

This is useful when doing tests: regression tests, or when you want FreeNLG to run the text generation and choose the same synonyms each time:

. Let FreeNLG choose the random seed, but output it to keep its track: `#{util.randomSeed}`
. When you want to make tests with the same synonyms: `freenlgPug.renderFile('template.pug', { language: xxx, forceRandomSeed: yyy } );`


anchor:why_freenlg[Why FreeNLG, the author etc.]

== Why FreeNLG, the author etc.

=== Commercial systems

NLG has existed for a long time as an academic subject but it is only recently that commercial NLG technology has become widely available and self service. 

World-class NLG actors are:

* Narrative Science
* Arria NLG
* Automated Insights
* Yseop

_(but there a some smaller actors here too - if you build one, contact me and I'll add you to the list)_

I have been working for and with Yseop NLG for a long time, doing dozens of NLG projects.

A comparison of FreeNLG with some commercial systems I known: <<compared>>

=== Open-source NLG ?

There is some open source for NLG but it is generally:

* Completely outdated or not maintained.
* It focuses on one very specific NLG feature (and does it well) but is not complete enough to build real life projects, e.g. https://github.com/simplenlg/simplenlg[SimpleNLG] that only adresses surface realisation.

https://ehudreiter.com/2017/03/17/open-source-nlg-software/[A blog post of Ehud Reiter about why there are no open-source generators]

So as you might have guessed I decided to write my own Natural Language Generator, and make it open-source.

=== FreeNLG's characteristics as a natural language generator

There are various techniques to generate texts. Template based generators use templates, which are a mix of static content (plain text) and dynamic content. Think of PHP etc.

In template-based system, most of the time you don't really care about the exact structure of the text (subject, verb, etc.). You don't need to be a linguist to use them: you only need a quite basic understanding of the output language grammar.


The characteristics of FreeNLG are:

* template-based
* easy to use
* based on modern & mature technologies: node.js & pug
* complete enough to build real life projects
* open-source of course


anchor:compared[FreeNLG compared to commercial NLG systems]

== FreeNLG compared to commercial NLG systems

.FreeNLG compared to Yseop NLG
[options="header", cols="3"]
|=====================================================================
| Characteristic  | FreeNLG  | Yseop
| Licence | open-source (MIT) | proprietary
| Language for templates | based on Pug, the leading node.js templating engine | proprietary language (but very well designed for NLG)
| Language for data prep | javascript | proprietary language
| Ecosystem | the whole node.js ecosystem | incorporated rule engine + some few libraries provided by Yseop
| Connectivity during execution | can connect to anything | cannot fetch data during execution
| Ease of authoring for technical users | quite good | average
| Ease of authoring for business users | not ready for business users | quite good for simple modifications
| Ease of installation | standard npm module | specific stack with Java and C++
| Ease of integration | in any node.js app or via Web Service | via Web Service only
| Continuous integration ability | as any other node.js app | difficult to achieve
| Speed of compilation | very fast (javascript generation) | average
| Speed of generation | fast: 1 text = 10-50 ms | not so fast: 1 text = 200-300 ms
| Synonyms algorithm | random based or sequence | proprietary algorithm
| Languages | good coverage on English and French | full coverage on English, French, German, Spanish, Dutch and Japanese
| Linguistic resources 
a| English: 

* verbs
* plurals of words

French: 

* gender of each word (_la couleur_ / _le poids_)
* plural of words
* agreement of adjectives 
* some verbs (group 1 & 2)
a|
* Verbs library on each supported language
* Large coverage of agreements and rules on each supported language
| Functional coverage | good | very broad
| Reliability | still under development | very reliable, years of debug
|=====================================================================

_(contact me if you want to add comparisons with other commercial NLG systems)_


